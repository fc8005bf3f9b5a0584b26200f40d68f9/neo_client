#!/usr/bin/env python3

from collections import Counter
from sympy.ntheory.modular import crt
from typing import Tuple, List
from pwn import *
import re
import sys
import time
import requests
import json
from hashlib import sha256
from os import urandom
from Crypto.Util.number import *

GAME_URL = "http://10.41.251.2/attack.json"
TEAM_IP = sys.argv[1]
TEAM_ID = TEAM_IP.split(".")[2] # 10.41.18.2 => 18

context.log_level = 'error'

SERVICE = "bbspriest" # nombre del servicio. Obtenerlo de http://10.41.251.2/attack.json

class Point:
	def __init__(self, x: int, y: int):
		self.x = x
		self.y = y
	
	def __str__(self):
		return f'({self.x}, {self.y})'

	def __repr__(self):
		return str(self)

	def __eq__(self, other: 'Point'):
		return self.x == other.x and self.y == other.y

	def isOnCurve(self):
		return (self.y ** 2) % p == (self.x ** 3 + a * self.x + b) % p or (self.x == 0 and self.y == 0)

	def isIdentity(self):
		return self.x == 0 and self.y == 0

	def add(self, p2: 'Point') -> 'Point':
		if self.x == 0 and self.y == 0:
			return Point(p2.x, p2.y)
		if p2.x == 0 and p2.y == 0:
			return Point(self.x, self.y)

		try:
			if self.x == p2.x and self.y == p2.y:
				slope = (3 * (self.x ** 2) + a) * pow(2 * self.y, -1, p)
				slope %= p
			else:
				slope = (p2.y - self.y) * pow(p2.x - self.x, -1, p)
				slope %= p
		except ValueError:
			return Point(0, 0)

		x3 = (slope ** 2) - self.x - p2.x
		y3 = slope * (self.x - x3) - self.y

		return Point(x3 % p, y3 % p)

	def mul(self, scalar: int) -> 'Point':
		base = Point(self.x, self.y)
		result = Point(0, 0)
		while scalar != 0:
			if scalar & 1 == 1:
				result = result.add(base)
			base = base.add(base)
			scalar >>= 1

		return result
G = Point(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)


def getFlagStorages():
    while True:
        try:
            r = requests.get(GAME_URL)
            resp_json = r.json()

            storages = resp_json["attack_info"][SERVICE][TEAM_IP]

        except:
            time.sleep(0.5)
            continue
        break

    return storages


storages = getFlagStorages()
# print(storages)

def sign(data: bytes, priv: int):
	z = int.from_bytes(data) % O
	k = int.from_bytes(urandom(30)) % O
	P = G.mul(k)
	r = P.x % O
	s = (pow(k, -1, O) * (z + r * priv)) % O

	return r, s

# def verify(data: bytes, pubkey: Point, sig: tuple[int, int]):
# 	z = int.from_bytes(sha256(data).digest()) % O
# 	r, s = sig
# 	assert r % O != 0 and s % O != 0
# 	sInv = pow(s, -1, O)
# 	u1 = (z * sInv) % O
# 	u2 = (r * sInv) % O

# 	P = G.mul(u1).add(pubkey.mul(u2))

# 	return (r - P.x) % O == 0

p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
O = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

def ec_add(P1: Tuple[int, int], P2: Tuple[int, int], a: int, p: int) -> Tuple[int, int]:
    if P1 is None:
        return P2
    if P2 is None:
        return P1
    x1, y1 = P1
    x2, y2 = P2
    if x1 == x2:
        if (y1 + y2) % p == 0:
            return None
        if y1 == y2:
            if y1 == 0:
                return None
            lam = (3 * x1 * x1 + a) * pow(2 * y1, p - 2, p) % p
        else:
            return None  # should not happen
    else:
        dx = (x2 - x1) % p
        lam = (y2 - y1) * pow(dx, p - 2, p) % p
    x3 = (lam * lam - x1 - x2) % p
    y3 = (lam * (x1 - x3) - y1) % p
    return (x3, y3)

def ec_scalar(k: int, P: Tuple[int, int], a: int, p: int) -> Tuple[int, int]:
    if k == 0 or P is None:
        return None
    result = None
    addend = P
    while k > 0:
        if k % 2 == 1:
            result = ec_add(result, addend, a, p)
        addend = ec_add(addend, addend, a, p)
        k //= 2
    return result

def solve_dlp_small_order(G: Tuple[int, int], Q: Tuple[int, int], order: int, a: int, p: int) -> int:
    if Q is None:
        return 0
    current = G
    j = 1
    if current == Q:
        return 1 % order
    while j < order:
        current = ec_add(current, G, a, p)
        j += 1
        if current == Q:
            return j
    return None

def pollard_rho_dlp(G: Tuple[int, int], Q: Tuple[int, int], order: int, a: int, p: int) -> int:
    def step(X: Tuple[int, int], alpha: int, beta: int) -> Tuple[Tuple[int, int], int, int]:
        if X is None:
            return None, alpha, beta
        h = int(X[0]) % 3
        if h == 0:
            Xn = ec_add(X, X, a, p)
            an = (2 * alpha) % order
            bn = (2 * beta) % order
        elif h == 1:
            Xn = ec_add(X, G, a, p)
            an = (alpha + 1) % order
            bn = beta
        else:
            Xn = ec_add(X, Q, a, p)
            an = alpha
            bn = (beta + 1) % order
        return Xn, an, bn

    for attempt in range(20):
        X = G
        alpha = 1 % order
        beta = 0
        Xt, alphat, betat = step(X, alpha, beta)
        Xh, alphah, betah = step(X, alpha, beta)
        Xh, alphah, betah = step(Xh, alphah, betah)
        steps = 0
        max_steps = int(4 * (order ** 0.5)) + 100
        while Xt != Xh and steps < max_steps:
            Xt, alphat, betat = step(Xt, alphat, betat)
            Xh, alphah, betah = step(Xh, alphah, betah)
            Xh, alphah, betah = step(Xh, alphah, betah)
            steps += 1
            if Xt is None or Xh is None:
                break
        if Xt == Xh and Xt is not None:
            da = (alphat - alphah) % order
            db = (betah - betat) % order
            if db != 0:
                try:
                    k = (da * pow(db, order - 2, order)) % order
                    if ec_scalar(k, G, a, p) == Q:
                        return k
                except:
                    pass
    return None

# Hardcoded data for the 5 curves with full factors
data = [
    {'full_factors': [71, 823, 1229, 7489, 30203, 1275057701, 5590685618197487513633360286414913886653362665945221],
     'G': (59789469400423071222234851675216581609229391787884996889514885236099570594463, 24693555803778376826663347852209275010344594049643244607560538002246234158193)},
    {'full_factors': [2, 2, 7, 13, 37, 97, 113, 65364863466230065009299609518518318921279098632127819301704248465833],
     'G': (102244111246911132069129854477879737337675719617188849037371767226541515465287, 50202944960235922754347890374869734895708594893459001248667605062554536207766)},
    {'full_factors': [2, 2, 13, 19, 179, 13003, 1307093479, 218034068577407083, 16884307952548170257, 10464321644447000442097],
     'G': (97145089773961705503596226511396714902183951752588643832894675444828365376134, 111724572498335655496701447971213653765030938586189140009192792325064607488378)},
    {'full_factors': [3, 13, 2447, 43333351749528183857746664058033075385207938864390055103100636196733549],
     'G': (20718008932641643755601814188490732495803126039356893458437534072284786541301, 72941228114807054463436188530634810317419965301391751011416368366681523171946)},
    {'full_factors': [2, 5, 4003, 16033, 102001, 884390526899024919222120216398419141830968591728388637593606029],
     'G': (29106903714538687000106084732234725772486100813553050992562923242386553478215, 104749457554829887082945954824931228663918742864822785791539997235136280055114)},
    {'full_factors': [2, 2, 29, 349, 13998374731216357, 14594520227108627509460787496885153005246714980644220773], 'G': (20425883732760826749714974209258579440903409036051459684877194733762109341290, 41505153050847028481419594871196866993401890711798377917907363363726416567379)},
    {'full_factors': [2, 2, 2, 11, 829, 16533715264025810459088602629898137007090483122096399798750769210485559], 'G': (52334614857483171675175768996488845504701356171687973359578738214459577136213, 16750206144607389708169113880598567827483100450824662637331031043384447048236)},
    {'full_factors': [2, 5, 79, 9908907301079, 1012951076968341211, 14602847926699518642638451537443634753584467], 'G': (32075957256679404111736913660273889963990022533574122420806277101569218319912, 34332616575132843351010980355818261731511486030863888323694082222879108894490)},
    {'full_factors': [3, 3, 3, 3, 5, 11, 433, 33493, 32946937, 37378582301887, 56678399820132721, 25676379404250278600715717683], 'G': (58403798541104491031578271690825794848361880916926628778305857234062959828855, 86110444359704609171064341180709459774722665541022327084412165952556452597758)},
    {'full_factors': [79, 348421982923057, 2103372806640672277841547273088700531044596267860959113043361], 'G': (23527156829774179029857504630303623043618283597118012435492835939044592575001, 30853668133334966491032853513247591827041463472816160936914591993750548964576)},
    {'full_factors': [7, 13, 1459046501411, 1610212439070043, 97241642647551057361, 5569714065245652925455863891], 'G': (4673157846424449029183536376885829567521219303790964409874560209262363865936, 36851666437959200458499416314744065808691382154609967942607972526186653615304)},
    {'full_factors': [2, 3, 3, 541, 977, 338074220367896387813510071426846746320616540330764086423819169361179], 'G': (93432276214857579999284517282220884495185038702416903477193560511822459197528, 10399580244389908599294720681987920952767043149143221834842752109539257261461)},
    {'full_factors': [3, 3, 3, 5, 7, 48013271, 1276015034819334805901920214563724045815892743541733324686545013239], 'G': (13422336283361255075146926097963753794739714877854234337238125883743545646755, 68255012747892464463581781287304609015435775154058360230698169356624478353027)},
    {'full_factors': [5, 5, 52061563, 3982912145462685946057, 446735996145601242326633900740750395299501077], 'G': (103370544437459368844680940554101039042820935105176744833131737622496251256600, 88263322364603993846574133890634986728827320463372358771780214027705013371683)},
    {'full_factors': [2, 5, 5789604460517812438134872347470378676472084800307764354258819895046804032923], 'G': (10733098457628788164684801128933454192806606824212462403833187939121310768335, 108592884419665844166878974732541495236335580811682714616975916058744001187678)},
    {'full_factors': [7, 11, 546827881, 20957659566223, 37720741348877, 869670067285542639922711269716588377333], 'G': (81801403426812124146412304886396580420342817578864213952720434689412499300780, 36361901662675668579114266020716274847401781382807391840169315344056731233149)},
    {'full_factors': [5, 7, 14630572739, 856377040543, 9951085827967, 26534690749335983215618400602998167321227], 'G': (86591491655117090645706464141287624726227928171545633673412748141073195750854, 43260663810481501235006302955645908082901574041655730475056007014372224676894)},
    {'full_factors': [5, 5, 109, 7103, 28181220551395283, 48630929615259123426584791, 2182570106486004868643732089], 'G': (48771940778369319215178631365323530635856523635143976042443041019179310054921, 59547737568736724826768075979375290555254814004348363072858069651223986630728)},
    {'full_factors': [2, 2, 2, 7, 751, 3554666436628557476408417, 774554662013797598667199012343758927600990994869], 'G': (99755264016323264556742312050796851622942790235425901237758716510663917186779, 33790788872755688975622007970302644536545559210579379831805141685678302521929)},
    {'full_factors': [31, 439, 2341, 249808519, 14549364272660882096098662722807068575274560423585034924309163], 'G': (59286266815455197213852282162338427219017536277837182751792497767649630587838, 22007087771504697608993051760245300237952271000254383582605267490045341513805)},
    {'full_factors': [2, 19, 1390144960157671619285682273891901, 1095986508497712384272067019321151952940153], 'G': (83358701985114980831767066354716969914493218812497613423310322605879366964533, 76122389682984199806986338087294192566239800357344302407500692518101712479283)},
    {'full_factors': [17736939791, 1290970560773, 1264223526390785538367395268773035038152242170901943487], 'G': (58452972172340050147923814073902479474166996901675478829577047212388138535814, 38749417101387291723722268374934688702320927939592731858657272752438345777483)},
    {'full_factors': [2, 2, 2, 3, 131, 673, 2281327, 406563745373, 3277876556159954266416598863113168606160332393987693], 'G': (29741480795751051229541531098163578642016407251406165925847521316651520600668, 55541943742203983621309979942671523001192969362304419277364216698993209936443)}
]

def recover_priv(pubkeys: List[Tuple[int, int]]) -> int:
    """
    Recovers the private key using invalid curve attack with Pohlig-Hellman (via baby-step for tiny orders, Pollard Rho for larger small factors)
    and CRT combination.
    
    Args:
        pubkeys: List of 5 public points (priv * G_i for each invalid G_i)
    
    Returns:
        The recovered private key (mod product of all small moduli)
    """
    # if len(pubkeys) != 5:
    #     raise ValueError("Exactly 5 public points required.")
    
    all_moduli = []
    all_rems = []
    small_threshold = 1000000
    for idx, pub in enumerate(pubkeys):
        d = data[idx]
        full_factors = d['full_factors']
        G = d['G']
        large_factors = [f for f in full_factors if f >= small_threshold]
        c = 1
        for f in large_factors:
            c *= f
        G_small = ec_scalar(c, G, a, p)
        Q_small = ec_scalar(c, pub, a, p)
        small_factors = [f for f in full_factors if f < small_threshold]
        fact_dict = Counter(small_factors)
        pe_list = []
        rem_list = []
        h_total = 1
        for pp, ee in fact_dict.items():
            h_total *= pp ** ee
        for prime, exp in fact_dict.items():
            pe = prime ** exp
            h = h_total // pe
            Gpe = ec_scalar(h, G_small, a, p)
            Qpe = ec_scalar(h, Q_small, a, p)
            j = solve_dlp_small_order(Gpe, Qpe, pe, a, p)
            if j is None:
                raise ValueError(f"Failed to solve DLP for curve {idx+1}, prime power {pe}")
            pe_list.append(pe)
            rem_list.append(j)
        ki, mi = crt(pe_list, rem_list)
        all_moduli.append(mi)
        all_rems.append(ki)
    
    priv, final_mod = crt(all_moduli, all_rems)
    # if final_mod < (1 << 256):  # Warn if not full coverage
        # print(f"Warning: Modulus {final_mod} may not cover full 256 bits (skipped large factors).")
    return priv

r = remote(sys.argv[1], 9999)

# print(storages)


pubs = []
for i in range(len(data)):
    H = data[i]['G']
    r.sendlineafter(b"> ", b"5")
    r.recv(1024)
    r.sendline(f"{H[0]}, {H[1]}".encode())
    r.recvuntil(b"Your private key ")
    pubkey = r.recvline().strip().decode()[:-1]
    m = re.match(r'\((\d+), (\d+)\)', pubkey)
    x = int(m.group(1))
    y = int(m.group(2))
    pubs.append((x, y))
    r.recv(1024)
    r.sendline(b"1")
    r.recv(1024)
    r.sendline(b"(1, 1)")

r.recvline()

recovered_priv = recover_priv(pubs)
# print(recovered_priv)
# recovered_priv = 779421386393503629143251892532717382073906024237555933066323062392744404

for storage in storages:
    id0 = storages[storage]["0"]    
    if id0:
        r.sendlineafter(b"> ", b"2")
        r.sendlineafter(b"> ", id0.encode())
        signature = sign(long_to_bytes(int(id0, 16)), int(recovered_priv))
        r.recv(1024)
        r.sendline(f"({signature[0]}, {signature[1]})".encode())
        line = r.recvline()
        # print(line)
        m = re.search(rb'ECSC\{[A-Za-z0-9_-]{32}\}', line)
        if m:
            print(m.group(0).decode())

